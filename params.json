{"name":"VIS","tagline":"Project Summary","body":"# Members\r\nJoseph Pober, error304@hotmail.de\r\n\r\n\r\n# Description\r\n\r\n## Target Application\r\nGeneCalc allows users to visualize datasets through R-Apps. This helps people with little to no experience in \r\n\r\nprogramming to utilise R. Instead of actually programming the desired plot, one simply selects a \r\n\r\nvisualization method (i.e. histogram) and enters the parameters into the provided textboxes. \r\nThe problem is that this whole workflow only works with exactly one set of parameters at a time. Many user \r\n\r\nwill want to test multiple ranges of parameters to find the desired result. Having to enter a set of \r\n\r\nparameters and then wait for the computer to finish the calculations does not only waste a lot of time it \r\n\r\nalso interrupts the workflow of the user considerably.\r\nSolving this problem requires users to be able to enter ranges of parameters instead of only a single set. \r\n\r\nWith this a problem in presentation arises, since many results in form of complex objects may appear and have \r\n\r\nto presented to the user. This will mostlikely be done by clustering the results and only showing examples or \r\n\r\naverages of those clusters to the user. They can then choose a to inpect a cluster, which either shows all \r\n\r\nresults of that cluster or shows again some subclusters of this cluster. Following the design principle of \r\n\r\nshowing first an overview and only later zooming in and providing details.\r\n\r\n\r\n## Dataset\r\nThe data is a table consisting mainly of floats. Each row represents a gene and each colum a celltype. The \r\n\r\nfloats try to show the likelyhood of a gene being responsible for a cell to form a certain celltype. Since \r\n\r\nthis is real world data, there is quite a lot of noise and often multiple samples of the same type must be \r\n\r\ntaken and recorded to be sure that the results are not distorted too much by noise.\r\n\r\nThe program is supposed to work with any data. The data described above is just used by the test users, since \r\n\r\nthose are biologists.\r\n\r\n\r\n## Users\r\nThe users will have little to no programming knowledge, but want to have powerful visualizations of their \r\n\r\ndata. \r\n\r\n\r\n## Tasks\r\n### Parameters\r\nThe current state of the program allows the user to access all available parameteres for each visualization \r\n\r\ntechnique. Most of which many users might not understand and are not necessary for the user to be able to \r\n\r\nchange themselves. It is important to figure out which parameteres should be presented to the user, which \r\n\r\nparameters should be set automatically, and which parameters could be hidden and only shown on demand.\r\n\r\n### Input\r\nAt the moment it is not possible to enter ranges for parameteres or multiple sets of parameteres at once. \r\n\r\nSince the goal of this project is to allow the program to accept multiple inputs and generate multiple \r\n\r\noutputs it is necessesary for the user to be able to input the desired parameter ranges.\r\n\r\n### Automatically Set Values\r\nSince users will be able to set ranges for parameters it is important to figure out a good step size \r\n\r\nautomatically. It is also important to have well suited default parameters and to calculate as many \r\n\r\nparameters as possible automatically. This way the user does not have to understand everything about the \r\n\r\nvisualization method of their choosing and still get reasonable results.\r\n\r\n### Show Randomness\r\nSome processes involve randomness, like k-means clustering, this has to be communicted to the user, since \r\n\r\nmultiple runs with identical input might result in different output. This also complicates saving models, \r\n\r\nsince models with the same input might still be different or produce different outputs.\r\n\r\n### Representation of Results\r\nMany complex objects at once are not easily presented to the user without them having to invest a lot of time \r\n\r\nto examine them all individually. It is therefor paramount to find a way to organize the output of the \r\n\r\nprogram in such a manner that users get first an overview of the generated output and then can request \r\n\r\ndetails for objects of interest. This will be the main focus and much more diffcult than the other tasks.\r\n\r\n### Generalization\r\nIt is important that the input ranges and the representation of the output work for all visualization \r\n\r\ntechniques and not only for a select few. This might be not as diffucult once a general solution for a single \r\n\r\nproblem is found.\r\n\r\n\r\n## Solution\r\n### Parameters\r\nA good solution would be to limit user input to control parameters and let the program itself decide the \r\n\r\nmodel parameteres. The model parameteres are still accessable by the user, but hidden until demanded and set \r\n\r\nby the program if left empty.\r\n\r\n### Input\r\nThis is actually quite easy. Instead of having one text box for each numeric parameter the would simply be \r\n\r\ntwo textboxes one named \"start\" and one \"end\". For non-numeric values one could use instead of drop-down \r\n\r\nmenus and radioboxes simple check-boxes to be able to activate all desired options.\r\n\r\n### Automatically Set Values\r\nThe main concern is the step size of parameteres with a range of values. The step size should be dynamic and \r\n\r\nfocus on areas of maximum change. There should be big steps where there is little change and small steps when \r\n\r\nparameter values get into certain areas with big changes. This leads to an array of steps for each parameter \r\n\r\ninstead of a fixed amount by which a parameter is incremeted.\r\n\r\n### Show Randomness\r\nOne way of pointing out randomness would be to show the seed which is being used to calculate the output. \r\n\r\nThis seed would also be saved so each time the user loads the model they get the same results. Users would \r\n\r\nalso be able to manually enter a desired seed.\r\n\r\n### Representation of Results\r\nThere are certainly many different solutions to this problem, but I think a very intuetiv solution would be \r\n\r\ntrying to cluster the output into a manageable amount of clusters and presenting those clusters to the user \r\n\r\ninstead of all results at once. To give the user an idea of how those clusters look like one could either \r\n\r\naverage all subclusters of this cluster and present a new output as thumbnail or select a specific \r\n\r\nrepresentative output and display this. Choosing a representative object would either be at random, which is \r\n\r\nnot really representative or choosing the object that is the most like all other objects in its cluster.\r\nWhen a cluster gets chosen by the user they are presentet either the individual objects in this cluster or a \r\n\r\ncouple of subclusters, depending on the amount of objects and method of clustering. This continues until no \r\n\r\nmore subclusters are needed to represent the objects.\r\n\r\n\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}